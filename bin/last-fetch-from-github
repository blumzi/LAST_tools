#!/bin/bash

source /etc/profile.d/last.sh

module_include lib/message
module_include lib/util
module_include sections/user

PROG=$(basename "${0}")
export LAST_TOOL_PID="${$}"

declare default_tokens_file tokens_file
default_tokens_file="$(module_locate files/github-tokens)"

export github_repos_file
github_repos_file="$(module_locate files/github-repos)"

declare -A git_repo git_checkout_info git_token_name

eval top_dir=~"${user_last}"/matlab

declare line repo url checkout_info token_name
while read -r line; do
    read -r repo url checkout_info token_name _ <<< "${line}"
    if [ ! "${repo}" ] || [ ! "${url}" ] || [ ! "${checkout_info}" ] || [ ! "${token_name}" ]; then
        message_fatal "Badly formed line \"${line}\" in \"${github_repos_file}\"."
    fi

 git_checkout_info["${repo}"]="${checkout_info}"
    git_token_name["${repo}"]="${token_name}"
          git_repo["${repo}"]="${url}"

done < <(util_uncomment "${github_repos_file}")

function sorted_repos() {
    declare -a sorted

    sorted=( "$( for i in ${!git_repo[*]}; do echo "${i}"; done | sort)" )
    echo "${sorted[@]}"
}

function help() {
    # shellcheck disable=SC2154
    cat << EOF

    This tool clones (or pulls) the LAST software from github.

    Usage: ${PROG} [-d|--dir dir] [-c|--check] [-t|--token-file dir]
           ${PROG} --help

     -c|--check:         check only, don't enforce
     -d|--dir <dir>:     fetch into the specified dir (default: current directory)
     -t|--token-file:    specify a file containing the github tokens (default: ${default_tokens_file})
     -h|--help:          show this help

     NOTE: This tool must be run as ${user_last}

     The following directories will contain the respective repo contents:

EOF
    list_repos
    echo ""
}

function list_repos() {
    local key

    # TBD: list tags and branches
    for key in $( sorted_repos ); do
        printf "       %s/%-35s %s\n" "${top_dir}" "${key}" "${git_repo[${key}]#*@}"
    done
}

OPTS=$( getopt -o 'hd:clt:' --long "help,dir:,check,list,token-file:" -n "${PROG}" -- "$@" )
eval set -- "${OPTS}"

check=false
while true; do
	case "${1}" in

    -d|--dir)
        top_dir="${2}"
        shift 2
        ;;

    -h|--help)
        help
        exit 0
        ;;

    -c|--check)
        check=true
        shift 1
        ;;

    -l|--list)
        list_repos
        exit 0
        ;;

    -t|--token-file)
        if [ ! -s "${2}" ]; then
            message_fatal "Missing or empty token file \"${2}\"."
            exit 1
        fi
        tokens_file="${2}"
        shift 2
        ;;

	--)
		shift 1
		break
		;;
	esac
done

if ${check}; then
    if [ ! -d "${top_dir}" ]; then
        message_fatal "No such directory \"${top_dir}\""
        exit 1
    fi

    declare -i errors=0
    cd "${top_dir}" || exit 1
    for dir in $( sorted_repos ); do
        if [ -d "${dir}" ] && [ -d "${dir}/.git" ]; then
            #
            # TBD: check branch and tag
            #
            pushd "${dir}" >/dev/null || true
            git status >/dev/null 2>&1
            status=$?
            if (( status == 0 )); then
                message_success "Repository \"${top_dir}/${dir}\" is OK"
            else
                message_failure "Git status on repository \"${top_dir}/${dir}\" failed (status: ${status})"
                (( errors++ ))
            fi
            popd >/dev/null || true
        else
            message_failure "Missing local repository ${top_dir}/${dir}"
            (( errors++ ))
        fi
    done
    exit $(( errors ))
fi

# enforce
if [ ! "${tokens_file}" ]; then
    tokens_file="${default_tokens_file}"
fi

export -A github_token=()

if [ ! -r "${tokens_file}" ]; then
    message_fatal "Cannot read tokens file \"${tokens_file}\""
fi

# shellcheck source=/dev/null
source "${tokens_file}"
if (( "${#github_token[@]}" == 0 )); then
    message_fatal "Could not load github tokens from \"${tokens_file}\""
    exit 1
fi

if [ ! -d "${top_dir}" ]; then
    mkdir -p "${top_dir}"
fi
cd "${top_dir}" || exit 1

declare repo status url checkout_info token_name token
for key in $( sorted_repos ); do
 checkout_info="${git_checkout_info["${key}"]}"
    token_name="${git_token_name[${key}]}"
         token="${github_token[${token_name}]}"
          repo="${git_repo[${key}]}"
           dir="${key}"

    if [ ! "${token}" ]; then
        message_fatal "Github token \"${token_name}\" for repo \"${repo}\" not found in \"${tokens_file}\""
    fi

    declare checkout_args tag branch msg

    if [ ! -d "${dir}/.git" ]; then
        mkdir -p "${dir}"
        pushd "$(dirname "${dir}")" >/dev/null || continue
        url="${repo/github/${token}@github}"
        git clone "${url}" >/dev/null 2>&1
        status=$?
        if [ "${status}" -eq 0 ]; then
            message_success "Cloned \"${repo}\" into \"${dir}\"."
            if [ "${checkout_info}" ] && [ "${checkout_info}" != "none" ]; then
                declare -a info
                read -r -a info <<< "${checkout_info//,/ }"
	        checkout_args="" tag="" branch="" msg=""

                for i in "${info[@]}"; do
                    case "${i}" in
                        tag:*)
			    tag="${info#tag:}"
                            checkout_args+="tags/${tag} "
			    msg+="tag=${tag} "
                            ;;
                        branch:*)
			    branch="${info#branch:}"
                            checkout_args+="${branch} "
			    msg+="branch=${branch} "
                            ;;
                    esac
                    
                done
                
                pushd "$(basename "${dir}")" >/dev/null || true
                git checkout ${checkout_args} >/dev/null 2>&1
                status=$?
                if (( status == 0 )); then
                    message_success "Checked out with ${msg} in \"${dir}\"."
                else
                    message_failure "Could not checkout with ${msg} in \"${dir}\" (status: ${status})"
                fi
                popd >/dev/null || true
            fi
        else
            message_failure "Could not clone \"${repo}\" into \"${dir}\" (status: ${status})"
        fi
        popd >/dev/null || continue
    else
        pushd "${dir}" >/dev/null || continue
        git pull --all --tags >/dev/null
        status=$?
        if (( status == 0 )); then
            message_success "Pulled from \"${repo}\" into \"${dir}\"."
        else
            message_failure "Could not pull from \"${repo}\" into \"${dir}\" (status: ${status})"
        fi
        popd >/dev/null || continue
    fi
done
