#!/bin/bash

trap "/bin/rm -rf ${tmp}" EXIT

# shellcheck disable=SC1091
source /etc/profile.d/last.sh

module_include lib/ansi
module_include lib/message
module_include lib/util
module_include lib/user
module_include sections/user

PROG=$(basename "${0}")
export LAST_TOOL_PID="${$}"

declare default_tokens_file tokens_file
default_tokens_file="$(module_locate files/github-tokens)"

export github_repos_file
github_repos_file="$(module_locate files/github-repos)"

declare -A git_repo git_checkout_info git_token_name
declare -a selected_repos
declare reclone=false

# shellcheck disable=SC2154
eval top_dir="${user_matlabdir}"

function load_repos_file() {
    declare line repo url checkout_info token_name
    while read -r line; do
        read -r repo url checkout_info token_name _ <<< "${line}"
        if [ ! "${repo}" ] || [ ! "${url}" ] || [ ! "${checkout_info}" ] || [ ! "${token_name}" ]; then
            message_fatal "Badly formed line \"${line}\" in \"${github_repos_file}\"."
        fi

    git_checkout_info["${repo}"]="${checkout_info}"
       git_token_name["${repo}"]="${token_name}"
             git_repo["${repo}"]="${url}"

    done < <(util_uncomment "${github_repos_file}")
}

function sorted_repos() {
    declare -a sorted

    sorted=( "$( for i in ${!git_repo[*]}; do echo "${i}"; done | sort)" )
    echo "${sorted[@]}"
}

function repo_was_selected() {
    local repo="${1}" r

    if [ ${#selected_repos[*]} -eq 0 ]; then
        return 0
    fi

    for r in "${selected_repos[@]}"; do
        if [ "${r}" = "${repo}" ]; then
            return 0
        fi
    done
    return 1
}

function help() {
    # shellcheck disable=SC2154
    cat << EOF

    This tool clones (or pulls) the LAST software from github.

    Usage: ${PROG} [[-r|--repo <repo>] ...] [-R|--reclone] [-d|--dir dir] [-c|--check] [-t|--token-file dir] [-s|--space <name>]
           ${PROG} --help

     -c|--check:         check only, don't enforce
     -d|--dir <dir>:     fetch into the specified dir (default: current directory)
     -t|--token-file:    specify a file containing the github tokens (default: ${default_tokens_file})
     -h|--help:          show this help
     -r|--repo <repo>:   specify repositories (default: all repositories)
     -R|--reclone:       discard local changes and re-clone the selected repositories (default: all) - DANGEROUS!!!
     -s|--space <name>:  use the named working space (default: as defined by $(module_locate files/github-repos))

     NOTE: This tool must be run as ${user_name}

     The following directories will contain the respective repo contents:

EOF
    list_repos
    echo ""
}

function list_repos() {
    local key

    # TBD: list tags and branches
    for key in $( sorted_repos ); do
        printf "       %s/%-35s %s\n" "${top_dir}" "${key}" "${git_repo[${key}]#*@}"
    done
}

OPTS=$( getopt -o 'hd:clt:r:Rs:' --long "help,dir:,check,list,token-file:,repo:,reclone,space:" -n "${PROG}" -- "$@" )
eval set -- "${OPTS}"

check=false
list=false
while true; do
	case "${1}" in

    -d|--dir)
        top_dir="${2}"
        shift 2
        ;;

    -h|--help)
        help
        exit 0
        ;;

    -c|--check)
        check=true
        shift 1
        ;;

    -l|--list)
        list=true
        shift 1
        ;;

    -t|--token-file)
        if [ ! -s "${2}" ]; then
            message_fatal "Missing or empty token file \"${2}\"."
            exit 1
        fi
        tokens_file="${2}"
        shift 2
        ;;

    -r|--repo)
        selected_repos+=( "${2}" )
        shift 2
        ;;

    -R|--reclone)
        reclone=true
        shift 1
        ;;
    
    -s|--space)
        space="${2}"
        shift 2
        ;;

	--)
		shift 1
		break
		;;
	esac
done

if [ "${space}" ]; then
    github_repos_file=$(module_locate files/github-repos.${space})
else
    github_repos_file=$(module_locate files/github-repos)
fi
load_repos_file

if ${list}; then
    list_repos
    exit 0
fi

load_repos_file

if ${check}; then
    if [ ! -d "${top_dir}" ]; then
        message_fatal "No such directory \"${top_dir}\""
        exit 1
    fi

    declare -i errors=0
    cd "${top_dir}" || exit 1
    echo ""
    echo "   Workspace: $(ansi_bright_green ${space:-production}) (file: ${github_repos_file})"
    echo ""
    for dir in $( sorted_repos ); do
        if ! repo_was_selected "${dir}"; then
            continue
        fi

        if [ -d "${dir}" ] && [ -d "${dir}/.git" ]; then
            #
            # TBD: check branch and tag
            #
            branch=''
            tag=''
            checkout_info=${git_checkout_info[${dir}]}
            for info in ${checkout_info//,/ }; do
                eval "${info/:/=}"
            done
            pushd "${dir}" >/dev/null || true
            current_branch="$(git branch --show-current)"
            current_tag="$(git describe --tags --abbrev=0 2>/dev/null)"
            git status >/dev/null 2>&1
            status=$?
            if (( status != 0 )); then
                message_failure "Git status on repository \"${top_dir}/${dir}\" failed (status: ${status})"
                (( errors++ ))
            else
                badies=()
                if [ "${branch}" != "${current_branch}" ]; then
                    badies+=( "branch \"${current_branch}\" instead of \"${branch}\"" )
                fi
                if [ "${tag}" ] && [ "${tag}" != "${current_tag}" ]; then
                    badies+=( "tag \"${current_tag}\" instead of \"${tag}\"" )
                fi

                if [ ${#badies[@]} -ne 0 ]; then
                    message_failure "Repository \"${top_dir}/${dir}\": $(util_str_join ", " "${badies[@]}")"
                    (( errors++ ))
                else
                    message_success "Repository \"${top_dir}/${dir}\" OK (${checkout_info})"
                fi
            fi
            popd >/dev/null || true
        else
            message_failure "Missing local repository ${top_dir}/${dir}"
            (( errors++ ))
        fi
    done

    exit $(( errors ))
fi

# enforce
if [ ! "${tokens_file}" ]; then
    tokens_file="${default_tokens_file}"
fi

export -A github_token=()

if [ ! -r "${tokens_file}" ]; then
    message_fatal "Cannot read tokens file \"${tokens_file}\""
fi

# shellcheck source=/dev/null
source <(util_uncomment "${tokens_file}")
if (( "${#github_token[@]}" == 0 )); then
    message_fatal "Could not load github tokens from \"${tokens_file}\""
    exit 1
fi

if [ ! -d "${top_dir}" ]; then
    mkdir -p "${top_dir}"
fi
cd "${top_dir}" || exit 1

declare repo status url checkout_info token_name token
for key in $( sorted_repos ); do
 checkout_info="${git_checkout_info["${key}"]}"
    token_name="${git_token_name[${key}]}"
         token="${github_token[${token_name}]}"
          user="${github_token_user[${token_name}]}"
          repo="${git_repo[${key}]}"
           dir="${key}"

    if ! repo_was_selected "${dir}"; then
        continue
    fi

    if [ ! "${token}" ]; then
        message_fatal "Github token \"${token_name}\" for repo \"${repo}\" not found in \"${tokens_file}\""
    fi

    declare checkout_args tag branch msg repo_msg

    repo_msg="{$(ansi_bold ${key})} "

    if ${reclone} && [ -d "${dir}/.git" ]; then
        message_info "${repo_msg} Removing ${top_dir}/${dir} (to be recloned) ..."
        /bin/rm -rf "${dir}"
    fi

    tmp=$(mktemp -d)

    if [ ! -d "${dir}/.git" ]; then
        mkdir -p "${dir}"
        pushd "$(dirname "${dir}")" >/dev/null || continue
        url="${repo/github/${token}@github}"
        message_info "${repo_msg} Cloning from ${repo} into \"${top_dir}/${dir}\" ..."
        git clone "${url}" > ${tmp}/out 2> ${tmp}/err
        status=$?
        if [ "${status}" -eq 0 ]; then
            message_success "${repo_msg} Cloned \"${repo}\" into \"${top_dir}/${dir}\"."
        else
            message_failure "${repo_msg} Could not clone \"${repo}\" into \"${top_dir}/${dir}\" (status: ${status})"
            while read -r line; do
                message_failure "${repo_msg} ${line}"
            done < ${tmp}/err
        fi
        /bin/rm ${tmp}/{out,err}
        popd >/dev/null || continue
    else
        pushd "${dir}" >/dev/null || continue
        message_info "${repo_msg} Fetching from ${repo} into \"${top_dir}/${dir}\" ..."
        # enforce current github token
        url="${repo/github.com/${token}@github.com}"
        git config --local remote.origin.url "${url}"

        # now pull
        git fetch --all --tags --jobs=4 > ${tmp}/out 2> ${tmp}/err
        status=$?
        if (( status == 0 )); then
            message_success "${repo_msg} Fetched from \"${repo}\" into \"${top_dir}/${dir}\"."
        else
            message_failure "${repo_msg} Could not fetch from \"${repo}\" into \"${top_dir}/${dir}\" (status: ${status})"
            while read -r line; do
                message_failure "${repo_msg} ${line}"
            done < ${tmp}/err
        fi
        /bin/rm ${tmp}/{out,err}
        popd >/dev/null || continue
    fi

    if (( ${status} != 0 )); then
        continue
    fi

    if [ "${checkout_info}" ] && [ "${checkout_info}" != "none" ]; then
        declare -a info
        read -r -a info <<< "${checkout_info//,/ }"
        checkout_args="" tag="" branch="" msg=""

        for i in "${info[@]}"; do
            case "${i}" in
                tag:*)
                    tag="${info#tag:}"
                    checkout_args+="tags/${tag} "
                    msg+="tag=$(ansi_bold ${tag}) "
                    ;;
                branch:*)
                    branch="${info#branch:}"
                    checkout_args+="${branch} "
                    msg+="branch=$(ansi_bold ${branch}) "
                    ;;
            esac                    
        done
        
        pushd "${dir}" >/dev/null || true
        #
        # Checkout the configured branch (may fail)
        #
        # shellcheck disable=SC2086
        git checkout ${checkout_args} > ${tmp}/out 2> ${tmp}/err
        status=$?
        if (( status == 0 )); then
            message_success "${repo_msg} Checked out ${msg} in \"${top_dir}/${dir}\"."
        else
            message_failure "${repo_msg} Could not checkout ${msg} in \"${top_dir}/${dir}\" (status: ${status})"
            while read -r line; do
                message_failure "${repo_msg} ${line}"
            done < ${tmp}/err
        fi
        /bin/rm ${tmp}/{out,err}

        if (( ${status} != 0 )); then
            continue
        fi

        #
        # Pull (merge)
        #
        git pull > ${tmp}/out 2> ${tmp}/err
        status=$?
        if (( status == 0 )); then
            message_success "${repo_msg} Pulled ${msg} in \"${top_dir}/${dir}\"."
        else
            message_failure "${repo_msg} Could not pull ${msg} in \"${top_dir}/${dir}\" (status: ${status})"
            while read -r line; do
                message_failure "${repo_msg} ${line}"
            done < ${tmp}/err
        fi
        /bin/rm ${tmp}/{out,err}
        popd >/dev/null || true
    fi
done
