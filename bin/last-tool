#!/bin/bash

source /etc/profile.d/last.sh

export PROG
PROG=$(basename "${0}")
export LAST_TOOL_PID="${$}"

module_include lib/message
module_include lib/macmap
module_include lib/container

declare mode

function list_sections() {
    message_info "$(printf '   %-12s %-64s %s\n' "Section" "Description" "Requires")"
    message_info "$(printf '   %-12s %-64s %s\n' "-------" "-----------" "--------")"
    for section in $( sections_registered_sections ); do
        message_info "$(printf '   %-12s %-64s %s\n' "${section}" "$(sections_section_description "${section}")" "$(sections_section_requires "${section}")" )"
    done | sort
}

function help() {
    cat << EOF

    The LAST installation policy is everything that differentiates a LAST installation
     from a vanilla Ubuntu installation (network, packages, matlab, LAST software, etc.)

    This tool either checks or enforces the LAST installation policy.

    Usage: ${PROG} [-q|--quiet] [-n|--nodeps] [-c|--container <path>] [-t|--token <token-or-file>] <mode> [[section] ...] 
           ${PROG} -h|--help

     -q|--quiet:       be silent (default: verbose)
     -n|--nodeps:      don't do section dependencies (default: dependant sections will be added)
     -c|--container:   select a LAST container (default: first valid container in LAST_CONTAINER_PATH)
     -t|--token:       specify a github token (either the token itself or a file containing the token)

     Running <mode>:
      One running <mode> must be selected from the following (no default):
        check:         Checks if the current machine complies with the LAST installation policy
        enforce:       Enforces the LAST installation policy upon the current machine
        show:          Shows some information about the available installation resources
        show-policy:   Prints out the LAST policy for the seected section(s)
        list-sections: Just list all the available sections

     Sections:
      The workload is split into (possibly inter-dependant) sections.
      - To get a list of the defined sections run:
          $ ${PROG} show
      - To select a subset of all the defined sections, just list them as arguments
         after the running <mode> (default: run all the defined sections)

EOF
}

function show_info() {
    local msg

    export LAST_TOOL_DONTLOG=true   # inform message_xxx not to log

    message_info ""
    message_info "Environment:"
    message_info " LAST_BASH_INCLUDE_PATH: ${LAST_BASH_INCLUDE_PATH}"
    message_info "        LAST_TOOL_QUIET: ${LAST_TOOL_QUIET}"

    message_info "Container(s):"
    message_info "  Selected: ${selected_container:-$(container_lookup)}"
    message_info "      Path: $(container_path)"
    message_info ""

    message_info "Matlab:"
    message_info "   Installed: $(matlab_installed_release)"
    
    local -a available_matlabs available_matlab_dirs
    if [ "${container}" ]; then
        read -r -a matlabs <<< "$(cd "${container}/matlab" || exit; echo R*)"
        for matlab in "${matlabs[@]}"; do
            if [ -r "${container}/matlab/${matlab}/disk1.iso" ] && [ -r "${container}/matlab/${matlab}/disk2.iso" ]; then
                available_matlabs+=( "${matlab}" )
                available_matlab_dirs+=( "${container}/matlab/${matlab}" )
            fi
        done

        if [ ${#available_matlabs[*]} -gt 0 ]; then
            for (( i = 0 ; i < ${#available_matlabs[*]}; i++ )); do
                message_info "   Available: ${available_matlabs[i]} in ${available_matlab_dirs[i]}"
            done
        else
            message_info "   Available: None"
        fi
    fi

    local license_file
    license_file="$(matlab_license_file)"
    msg="   License File:           "       
    if [ -r "${license_file}" ]; then
        msg+="${license_file}"
    else
        msg+="Missing"
    fi
    message_info "${msg}"
    message_info ""

    message_info "Sections:"
    message_info " Available:"
    list_sections

    message_info ""
    message_info " Selected (ordered, including dependencies):"
    for section in "${needed_sections[@]}"; do
        message_info "$(printf '   %-12s %s\n' "${section}" "$(sections_section_description "${section}")")"
    done

    local mac ipaddr hostname
    mac="$(macmap_get_local_mac)" || message_fatal "Cannot get local MAC"
    ipaddr="$(macmap_get_local_ipaddr)" || message_fatal "Cannot get IP address for local mac: ${mac}"
    hostname="$(macmap_get_local_hostname)" || message_fatal "Cannot get hostname for local mac: ${mac}"
    message_info ""
    message_info "Network:"
    message_info "   MAC:        ${mac:-Could not get it}"
    message_info "   IP address: ${ipaddr:-Could not get it}"
    message_info "   hostname:   ${hostname:-Could not get it}"
    message_info ""
}

function root_or_die() {
    if [ "$(id -un)" != root ]; then
        echo "${PROG}: Must be root to run this tool!"
        exit 1
    fi
}

declare nodeps=false
export  github_token

while true; do
    case "${1}" in
        -h|--help)
            help
            exit 0
            ;;
        
        check|enforce|show|list-sections)
            mode="${1}"
            shift 1
            break
            ;;

        show-policy|policy)
            mode=policy
            shift 1
            ;;

        -q|--quiet)
            export LAST_TOOL_QUIET=true
            shift 1
            ;;

        -n|--nodeps)
            nodeps=true
            shift 1
            ;;

        -c|--container)
            selected_container="${2}"
            shift 2
            ;;

        -t|--token)
            if [ ! "${2}" ]; then
                message_fatal "The github token parameter cannot be empty.  Must be either a file name ot the token itself"
            fi

            if [ -s "${2}" ]; then
                github_token=$(< "${2}")
            else
                github_token="${2}"
            fi
            shift 2
            ;;

		*)
			break
			;;

    esac
done

if [ ! "${selected_container}" ]; then
    selected_container="$( container_lookup )"
fi

if [ ! "${mode}" ]; then
    message_failure "No running mode (check|enforce|show|policy) was selected, see help below!"
    help
    exit 1
fi

selected_sections=( "${@}" )

#
# These modules will register sections
#
module_include sections/bios
module_include sections/user
module_include sections/packages
module_include sections/profile
module_include sections/hostname
module_include sections/apt
module_include sections/paths
module_include sections/matlab
module_include sections/filesystems
module_include sections/time
module_include sections/catalogs
module_include sections/software

if [ "${mode}" = "list-sections" ]; then
    list_sections
    exit 0
fi

read -r -a registered_sections <<< "$( sections_registered_sections )"

declare known
for section in "${selected_sections[@]}"; do
	known=false
	for s in "${registered_sections[@]}"; do
		if [ "${s}" = "${section}" ]; then
			known=true
			break
		fi
	done
	if ! ${known}; then
		message_fatal "Unknown section \"${section}\""
	fi
done

# No sections were specified, use all those defined
if [ ${#selected_sections[*]} -eq 0 ]; then
    selected_sections=( "${registered_sections[@]}" )
fi

if ${nodeps}; then
    needed_sections=( "${selected_sections[@]}" )
else
    # build a topologically sorted array of the needed section
    read -r -a needed_sections <<< "$( sections_ordered_sections "${selected_sections[*]}" )"
fi

case "${mode}" in
show)
    show_info
    exit 0
    ;;

check)
    export LAST_TOOL_DONTLOG=true
    ;;

enforce)
    :
    ;;
esac

root_or_die

for section in "${needed_sections[@]}"; do
    if sections_section_has_method "${section}" "${mode}"; then
        message_section "${section^?}"

        eval "${section}_${mode}"
    else
        message_warning "Section \"${section}\" does not have a \"${section}_${mode}\" method, skipping"
    fi
done
