#!/bin/bash

source /etc/profile.d/last.sh

export PROG
PROG=$(basename "${0}")
export LAST_TOOL_PID="${$}"

module_include lib/message
module_include lib/macmap
module_include lib/deploy

declare mode

function help() {
    cat << EOF

    The LAST installation policy is everything that differentiates a LAST installation
     from a vanilla Ubuntu installation (network, packages, matlab, LAST software, etc.)

    This tool either checks or enforces the LAST installation policy.

    Usage: ${PROG} [-q|--quiet] [-n|--nodeps] <mode> [[section] ...] 
           ${PROG} -h|--help

     -q|--quiet:             be silent
     -n|--nodeps:            don't do section dependencies

     Running <mode>:
      One running <mode> must be selected from the following (no default):
        check:   Checks if the current machine complies with the LAST installation policy
        enforce: Enforces the LAST installation policy upon the current machine
        show:    Shows some information about the available installation resources
        policy:  Prints out the LAST policy for the seected section(s)

     Sections:
      The workload is split into (possibly inter-dependant) sections.
      - To get a list of the defined sections run:
          $ ${PROG} show
      - To select a subset of all the defined sections, just list them as arguments
         after the running <mode> (default: run all the defined sections)

EOF
}

function show_info() {
    local msg

    export LAST_TOOL_DONTLOG=true   # inform message_xxx not to log
    local deploy_dir
    deploy_dir=$(deploy_container)

    message_info ""
    message_info "Environment:"
    message_info " LAST_BASH_INCLUDE_PATH: ${LAST_BASH_INCLUDE_PATH}"
    message_info "        LAST_TOOL_QUIET: ${LAST_TOOL_QUIET}"
    message_info "                  Media: ${deploy_dir}"
    message_info ""

    message_info "Matlab:"
    message_info "   Installed: $(matlab_installed_release)"
    
    local -a available_matlabs available_matlab_dirs
    if [ "${deploy_dir}" ]; then
        read -r -a matlabs <<< "$(cd "${deploy_dir}/matlab" || exit; echo R*)"
        for matlab in "${matlabs[@]}"; do
            if [ -r "${deploy_dir}/matlab/${matlab}/disk1.iso" ] && [ -r "${deploy_dir}/matlab/${matlab}/disk2.iso" ]; then
                available_matlabs+=( "${matlab}" )
                available_matlab_dirs+=( "${deploy_dir}/matlab/${matlab}" )
            fi
        done

        if [ ${#available_matlabs[*]} -gt 0 ]; then
            for (( i = 0 ; i < ${#available_matlabs[*]}; i++ )); do
                message_info "   Available: ${available_matlabs[i]} in ${available_matlab_dirs[i]}"
            done
        else
            message_info "   Available: None"
        fi
    fi

    local keys_file
    keys_file="$(matlab_file_installation_keys)"
    msg="   Installation Keys File: "
    if [ -r "${keys_file}" ]; then
        msg+="${keys_file}"
    else
        msg+="Missing"
    fi
    message_info "${msg}"

    local license_file
    license_file="$(matlab_license_file)"
    msg="   License File:           "       
    if [ -r "${license_file}" ]; then
        msg+="${license_file}"
    else
        msg+="Missing"
    fi
    message_info "${msg}"
    message_info ""

    message_info "Sections:"
    message_info " Available:"
    for section in $( sections_registered_sections ); do
        message_info "$(printf '   %-12s %s\n' "${section}" "$(sections_section_description "${section}")")"
    done | sort

    message_info ""
    message_info " Selected (ordered, including dependencies):"
    for section in "${needed_sections[@]}"; do
        message_info "$(printf '   %-12s %s\n' "${section}" "$(sections_section_description "${section}")")"
    done

    local mac ipaddr hostname
    mac="$(macmap_get_local_mac)" || message_fatal "Cannot get local MAC"
    ipaddr="$(macmap_get_local_ipaddr)" || message_fatal "Cannot get IP address for local mac: ${mac}"
    hostname="$(macmap_get_local_hostname)" || message_fatal "Cannot get hostname for local mac: ${mac}"
    message_info ""
    message_info "Network:"
    message_info "   MAC:        ${mac:-Could not get it}"
    message_info "   IP address: ${ipaddr:-Could not get it}"
    message_info "   hostname:   ${hostname:-Could not get it}"
    message_info ""
}

function root_or_die() {
    if [ "$(id -un)" != root ]; then
        echo "${PROG}: Must be root to run this tool!"
        exit 1
    fi
}

declare nodeps=false
while true; do
    case "${1}" in
        -h|--help)
            help
            exit 0
            ;;
        
        check|enforce|show|policy)
            mode="${1}"
            shift 1
            break
            ;;

        -q|--quiet)
            export LAST_TOOL_QUIET=true
            shift 1
            ;;

        -n|--nodeps)
            nodeps=true
            shift 1
            ;;
    esac
done

if [ ! "${mode}" ]; then
    message_failure "No running mode (check|enforce|show|policy) was selected, see help below!"
    help
    exit 1
fi

selected_sections=( "${@}" )

#
# These modules will register sections
#
module_include sections/bios
module_include sections/user
module_include sections/packages
module_include sections/profile
module_include sections/hostname
module_include sections/apt
module_include sections/paths
module_include sections/matlab
module_include sections/filesystems
module_include sections/time
module_include sections/catalogs
module_include sections/software

read -r -a registered_sections <<< "$( sections_registered_sections )"

# No sections were specified, use all those defined
if [ ${#selected_sections[*]} -eq 0 ]; then
    selected_sections=( "${registered_sections[@]}" )
fi

if ${nodeps}; then
    needed_sections=( "${selected_sections[@]}" )
else
    # build a topologically sorted array of the needed section
    read -r -a needed_sections <<< "$( sections_ordered_sections "${selected_sections[*]}" )"
fi

case "${mode}" in
show)
    show_info
    exit 0
    ;;

check)
    export LAST_TOOL_DONTLOG=true
    ;;

enforce)
    :
    ;;
esac

root_or_die

for section in "${needed_sections[@]}"; do
    if sections_section_has_method "${section}" "${mode}"; then
        message_section "${section^?}"

        eval "${section}_${mode}"
    else
        message_warning "Section \"${section}\" does not have a \"${section}_${mode}\" method, skipping"
    fi
done